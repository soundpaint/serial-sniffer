/*
 * serial-sniffer -- a serial port sniffer and logger
 *
 * Copyright (C) 2021 JÃ¼rgen Reuter
 *
 * This file is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published
 * by the Free Software Foundation; either version 2 of the License,
 * or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 *
 * As a special exception to the GNU General Public License, if you
 * distribute this file as part of a program that contains a
 * configuration script generated by Autoconf, you may include it
 * under the same distribution terms that you use for the rest of that
 * program.
 *
 * For updates and more info or contacting the author, visit:
 * <https://github.com/soundpaint/serial-sniffer>
 *
 * Author's web site: www.juergen-reuter.de
 */

#include <control-serial-ports-panel.hh>
#include <log.hh>
#include <uart.hh>

Control_serial_ports_panel::Control_serial_ports_panel(App_control *app_control,
                                                       QWidget *parent)
  : QGroupBox(tr("Serial &Ports"), parent)
{
  if (!app_control) {
    Log::fatal("Control_serial_ports_panel::Control_serial_ports_panel(): "
               "app_control is NULL");
  }
  _app_control = app_control;

  _layout = new QVBoxLayout();
  if (!_layout) {
    Log::fatal("Control_serial_ports_panel::Control_serial_ports_panel(): "
               "not enough memory");
  }
  setLayout(_layout);

  _buttons_panels = new std::vector<QWidget *>();
  _buttons_layouts = new std::vector<QHBoxLayout *>();
  _labels_line_name = new std::vector<QLabel *>();
  _buttons_start = new std::map<const uint32_t, QPushButton *>();
  _buttons_stop = new std::map<const uint32_t, QPushButton *>();
  const std::vector<const IUart_info *> uarts = _app_control->get_all_uarts();
  for (auto uart_info = std::begin(uarts);
      uart_info != std::end(uarts); ++uart_info) {
    const std::vector<const ILine_info *> lines =
      ((Uart *)(*uart_info))->get_all_lines();
    for (auto line_info = std::begin(lines);
         line_info != std::end(lines); ++line_info) {
      ((Line *)(*line_info))->add_status_listener(this);
      QWidget *buttons_panel = new QWidget();
      if (!buttons_panel) {
        Log::fatal("Control_serial_ports_panel::Control_serial_ports_panel(): "
                   "not enough memory");
      }
      _buttons_panels->push_back(buttons_panel);
      _layout->addWidget(buttons_panel);

      QHBoxLayout *buttons_layout = new QHBoxLayout();
      if (!buttons_layout) {
        Log::fatal("Control_serial_ports_panel::Control_serial_ports_panel(): "
                   "not enough memory");
      }
      _buttons_layouts->push_back(buttons_layout);
      buttons_panel->setLayout(buttons_layout);

      std::string line_name = (*line_info)->get_full_name();
      QLabel *label_line_name = new QLabel(tr(line_name.c_str()));
      if (!label_line_name) {
        Log::fatal("Control_serial_ports_panel::Control_serial_ports_panel(): "
                   "not enough memory");
      }
      _labels_line_name->push_back(label_line_name);
      buttons_layout->addWidget(label_line_name);

      buttons_layout->addStretch();

      const uint32_t line_id = (*line_info)->get_id();

      // start button
      QPushButton *button_start = new QPushButton(tr("Start"), this);
      if (!button_start) {
        Log::fatal("Control_serial_ports_panel::Control_serial_ports_panel(): "
                 "not enough memory");
      }
      button_start->setEnabled(true);
      buttons_layout->addWidget(button_start);
      add_button(_buttons_start, line_id, button_start);

      // stop button
      QPushButton *button_stop = new QPushButton(tr("Stop"), this);
      if (!button_stop) {
        Log::fatal("Control_serial_ports_panel::Control_serial_ports_panel(): "
                   "not enough memory");
      }
      button_stop->setEnabled(false);
      button_stop->setAutoDefault(true);
      button_stop->setDefault(true);
      buttons_layout->addWidget(button_stop);
      add_button(_buttons_stop, line_id, button_stop);
    }
  }

  _layout->addStretch();
  create_actions();
}

Control_serial_ports_panel::~Control_serial_ports_panel()
{
  // locally managed Qt objects
  const std::vector<const IUart_info *> uarts = _app_control->get_all_uarts();
  for (auto uart_info = std::begin(uarts);
       uart_info != std::end(uarts); ++uart_info) {
    const std::vector<const ILine_info *> lines =
      ((Uart *)(*uart_info))->get_all_lines();
    for (auto line_info = std::begin(lines);
         line_info != std::end(lines); ++line_info) {
      ((Line *)(*line_info))->remove_status_listener(this);
      const uint32_t line_id = (*line_info)->get_id();
      (*_buttons_start)[line_id]->deleteLater();
      (*_buttons_start)[line_id] = 0; // TODO: remove entry from map
      (*_buttons_stop)[line_id]->deleteLater();
      (*_buttons_stop)[line_id] = 0; // TODO: remove entry from map
    }
  }
  for (auto buttons_layout = std::begin(*_buttons_layouts);
       buttons_layout != std::end(*_buttons_layouts); ++buttons_layout) {
    (*buttons_layout)->deleteLater();
    (*buttons_layout) = 0;
  }
  for (auto buttons_panel = std::begin(*_buttons_panels);
       buttons_panel != std::end(*_buttons_panels); ++buttons_panel) {
    (*buttons_panel)->deleteLater();
    (*buttons_panel) = 0;
  }
  for (auto label_line_name = std::begin(*_labels_line_name);
       label_line_name != std::end(*_labels_line_name); ++label_line_name) {
    (*label_line_name)->deleteLater();
    (*label_line_name) = 0;
  }
  delete _buttons_layouts;
  _buttons_layouts = 0;
  delete _buttons_panels;
  _buttons_panels = 0;
  delete _labels_line_name;
  _labels_line_name = 0;
  delete _buttons_start;
  _buttons_start = 0;
  delete _buttons_stop;
  _buttons_stop = 0;
  _layout->deleteLater();
  _layout = 0;

  // elsewhere managed objects
  _app_control = 0;
}

void
Control_serial_ports_panel::create_actions()
{
  const std::vector<const IUart_info *> uarts = _app_control->get_all_uarts();
  for(auto uart_info = std::begin(uarts);
      uart_info != std::end(uarts); ++uart_info) {
    const std::vector<const ILine_info *> lines =
      ((Uart *)(*uart_info))->get_all_lines();
    for (auto line_info = std::begin(lines);
         line_info != std::end(lines); ++line_info) {
      const uint32_t line_id = (*line_info)->get_id();
      connect((*_buttons_start)[line_id], &QPushButton::released,
              this, [=](){ this->start_line(line_id); });
      connect((*_buttons_stop)[line_id], &QPushButton::released,
              this, [=](){ this->stop_line(line_id); });
    }
  }
}

void
Control_serial_ports_panel::
add_button(std::map<const uint32_t, QPushButton *> *map,
           const uint32_t id,
           QPushButton *button)
{
  std::map<const uint32_t, QPushButton *>::iterator iter = map->find(id);
  if (iter != map->end()) {
    std::stringstream msg;
    msg << "Control_serial_ports_panel::add_button(): id "
        << id << " already assigned to button "
        << iter->second;
    Log::fatal(msg.str());
  }
  (*map)[id] = button;
}

void
Control_serial_ports_panel::start_line(const uint32_t id)
{
  (*_buttons_start)[id]->setEnabled(false);
  _app_control->start_line(id);
}

void
Control_serial_ports_panel::stop_line(const uint32_t id)
{
  {
    std::stringstream msg;
    msg << "[CSPP] stop_line "
        << id;
    Log::debug(msg.str());
  }
  (*_buttons_stop)[id]->setEnabled(false);
  _app_control->stop_line(id);
}

void
Control_serial_ports_panel::line_started(const ILine_info *line)
{
  (*_buttons_start)[line->get_id()]->setEnabled(false);
  (*_buttons_stop)[line->get_id()]->setEnabled(true);
}

void
Control_serial_ports_panel::line_stopped(const ILine_info *line)
{
  (*_buttons_start)[line->get_id()]->setEnabled(true);
  (*_buttons_stop)[line->get_id()]->setEnabled(false);
}

/*
 * Local variables:
 *   mode: c++
 *   coding: utf-8
 * End:
 */
