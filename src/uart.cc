/*
 * serial-sniffer -- a serial port sniffer and logger
 *
 * Copyright (C) 2021 JÃ¼rgen Reuter
 *
 * This file is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published
 * by the Free Software Foundation; either version 2 of the License,
 * or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 *
 * As a special exception to the GNU General Public License, if you
 * distribute this file as part of a program that contains a
 * configuration script generated by Autoconf, you may include it
 * under the same distribution terms that you use for the rest of that
 * program.
 *
 * For updates and more info or contacting the author, visit:
 * <https://github.com/soundpaint/serial-sniffer>
 *
 * Author's web site: www.juergen-reuter.de
 */

#include <uart.hh>
#include <unistd.h>
#include <fcntl.h>
#include <log.hh>
#include <iconfig.hh>

uint32_t Uart::_next_id = 1;

uint32_t
Uart::create_id()
{
  return _next_id++;
}

Uart::Uart(App_control *app_control, const std::string name,
           const std::string dev_path)
{
  // * see also autoconfig parameter of linux setserial command
  // * see also "automatic baud rate detection (ABR, autobaud)"
  if (!app_control) {
    Log::fatal("Uart::Uart(): app_control is NULL");
  }
  _app_control = app_control;

  _id = create_id();
  _name = std::string(name);
  _dev_path = std::string(dev_path);

  open_uart();
  setup_options();

  const IConfig *config = _app_control->get_config();
  const uint32_t buffer_size = config->get_serial_buffer_size();
  _line_in = new Line_in(this, _filestream, buffer_size);
  if (!_line_in) {
    Log::fatal("Uart::Uart(): not enough memory");
  }
  _line_out = new Line_out(this, _filestream, buffer_size);
  if (!_line_out) {
    Log::fatal("Uart::Uart(): not enough memory");
  }
}

Uart::~Uart()
{
  // locally managed non-Qt objects
  close();
  delete _line_in;
  _line_in = 0;
  delete _line_out;
  _line_out = 0;
  _name.clear();
  _dev_path.clear();

  // elsewhere managed objects
  _app_control = 0;

  _id = 0;
}

void
Uart::close()
{
  _line_in->stop(true);
  _line_in->quit();
  _line_out->stop(true);
  _line_out->quit();
}

const uint32_t
Uart::get_id() const
{
  return _id;
}

const std::string
Uart::get_name() const
{
  return _name;
}

void
Uart::add_status_listener(ILine_status_listener *listener)
{
  _line_in->add_status_listener(listener);
  _line_out->add_status_listener(listener);
}

void
Uart::remove_status_listener(ILine_status_listener *listener)
{
  _line_in->remove_status_listener(listener);
  _line_out->remove_status_listener(listener);
}

void
Uart::add_event_listener(ISerial_event_listener *listener)
{
  _line_in->add_event_listener(listener);
  _line_out->add_event_listener(listener);
}

void
Uart::remove_event_listener(ISerial_event_listener *listener)
{
  _line_in->remove_event_listener(listener);
  _line_out->remove_event_listener(listener);
}

void
Uart::propagate_input_to(const Uart *other)
{
  _line_in->add_event_listener(other->_line_out);
}

void
Uart::unpropagate_input_to(const Uart *other)
{
  _line_in->remove_event_listener(other->_line_out);
}

const std::vector<const ILine_info *>
Uart::get_all_lines() const
{
  std::vector<const ILine_info *> lines = std::vector<const ILine_info *>();
  lines.push_back(_line_in);
  lines.push_back(_line_out);
  return lines;
}

void
Uart::open_uart()
{
  const int filestream =
    open(_dev_path.c_str(), O_RDWR | O_NOCTTY | O_NDELAY);
  if (filestream == -1) {
    Log::fatal("Error - Unable to open UART.  "
               "Ensure it is not in use by another application.");
  }
  _filestream = filestream;
}

void
Uart::setup_options()
{
  // cp. https://blog.mbedded.ninja/programming/operating-systems/linux/linux-serial-ports-using-c-cpp/

  struct termios options;
  memset(&options, 0, sizeof(options));
  tcgetattr(_filestream, &options);

  const IConfig *config = _app_control->get_config();
  switch (config->get_serial_baud_rate()) {
    // see termios.h for valid values
  case 0:
    options.c_cflag |= B0;
    break;
  case 50:
    options.c_cflag |= B50;
    break;
  case 75:
    options.c_cflag |= B75;
    break;
  case 110:
    options.c_cflag |= B110;
    break;
  case 134:
    options.c_cflag |= B134;
    break;
  case 150:
    options.c_cflag |= B150;
    break;
  case 200:
    options.c_cflag |= B200;
    break;
  case 300:
    options.c_cflag |= B300;
    break;
  case 600:
    options.c_cflag |= B600;
    break;
  case 1200:
    options.c_cflag |= B1200;
    break;
  case 1800:
    options.c_cflag |= B1800;
    break;
  case 2400:
    options.c_cflag |= B2400;
    break;
  case 4800:
    options.c_cflag |= B4800;
    break;
  case 9600:
    options.c_cflag |= B9600;
    break;
  case 19200:
    options.c_cflag |= B19200;
    break;
  case 38400:
    options.c_cflag |= B38400;
    break;
  case 57600:
    options.c_cflag |= B57600;
    break;
  case 115200:
    options.c_cflag |= B115200;
    break;
  case 230400:
    options.c_cflag |= B230400;
    break;
  default:
    Log::fatal("unexpected case fall-through");
  }

  switch (config->get_serial_data_bits()) {
  case IConfig::seven:
    options.c_cflag |= CS7;
    break;
  case IConfig::eight:
    options.c_cflag |= CS8;
    break;
  default:
    Log::fatal("unexpected case fall-through");
  }

  switch (config->get_serial_parity_bit()) {
  case IConfig::none:
    // keep flags unmodified
    break;
  case IConfig::even:
    options.c_cflag |= PARENB;
    break;
  case IConfig::odd:
    options.c_cflag |= PARENB | PARODD;
    break;
  default:
    Log::fatal("unexpected case fall-through");
  }

  switch (config->get_serial_stop_bits()) {
  case IConfig::one:
    // keep flags unmodified
    break;
  case IConfig::two:
    options.c_cflag |= CSTOPB;
    break;
  default:
    Log::fatal("unexpected case fall-through");
  }

  options.c_cflag |= CLOCAL | CREAD;
  options.c_iflag = IGNPAR;
  options.c_oflag = 0;
  options.c_lflag = 0;
  tcflush(_filestream, TCIFLUSH);
  tcsetattr(_filestream, TCSANOW, &options);
}

void
Uart::start_receiving(const bool ignore_status)
{
  return _line_in->start(ignore_status);
}

void
Uart::stop_receiving(const bool ignore_status)
{
  return _line_in->stop(ignore_status);
}

const bool
Uart::is_receiving() const
{
  return _line_in->is_running();
}

void
Uart::start_transmitting(const bool ignore_status)
{
  return _line_out->start(ignore_status);
}

void
Uart::stop_transmitting(const bool ignore_status)
{
  return _line_out->stop(ignore_status);
}

const bool
Uart::is_transmitting() const
{
  return _line_out->is_running();
}

void
Uart::filter_line_out_for_line(const ILine_info *line_info)
{
  _line_out->filter_for_line(line_info);
}

void
Uart::notify_event(const Serial_event *event)
{
  _line_out->notify_event(event);
}

std::ostream &operator <<(std::ostream &os, const Uart &uart)
{
  os << "Uart(name=" << uart.get_name() << ", id=" << uart.get_id() << ")";
  return os;
}

/*
 * Local variables:
 *   mode: c++
 *   coding: utf-8
 * End:
 */
