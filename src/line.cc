/*
 * serial-sniffer -- a serial port sniffer and logger
 *
 * Copyright (C) 2021 JÃ¼rgen Reuter
 *
 * This file is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published
 * by the Free Software Foundation; either version 2 of the License,
 * or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 *
 * As a special exception to the GNU General Public License, if you
 * distribute this file as part of a program that contains a
 * configuration script generated by Autoconf, you may include it
 * under the same distribution terms that you use for the rest of that
 * program.
 *
 * For updates and more info or contacting the author, visit:
 * <https://github.com/soundpaint/serial-sniffer>
 *
 * Author's web site: www.juergen-reuter.de
 */

#include <line.hh>
#include <sstream>
#include <algorithm>
#include <log.hh>

const std::string
Line::STR_RX = std::string("RX");

const std::string
Line::STR_TX = std::string("TX");

uint32_t Line::_next_id = 1;

uint32_t
Line::create_id()
{
  return _next_id++;
}

Line::Line(const line_type_t line_type,
           const std::string name,
           const std::string group_name,
           const int filestream,
           const uint32_t buffer_size)
{
  _line_type = line_type;
  _name = std::string(name);
  _group_name = group_name;
  _filestream = filestream;
  _buffer_size = buffer_size;
  _id = create_id();

  _event_listeners = new std::vector<ISerial_event_listener *>();
  if (!_event_listeners) {
    Log::fatal("Line::Line(): not enough memory");
  }

  _status_listeners = new std::vector<ILine_status_listener *>();
  if (!_status_listeners) {
    Log::fatal("Line::Line(): not enough memory");
  }

  _buffer = new unsigned char[_buffer_size + 1]; // +1 for terminating \0
  if (!_buffer) {
    Log::fatal("Line::Line(): not enough memory");
  }

  _pause_requested = false;
  _resume_requested = false;
  _quit_requested = false;
  _is_running = false;
  _transfer_thread = new std::thread(transfer_loop_static, this);
  if (!_transfer_thread) {
    Log::fatal("Line::Line(): not enough memory");
  }
  _transfer_interrupt.sa_handler = handle_transfer_interrupt;
  sigemptyset(&_transfer_interrupt.sa_mask);
  _transfer_interrupt.sa_flags = 0;

}

Line::~Line()
{
  if (_transfer_thread) {
    Log::fatal("Line::~Line(): "
               "must stop transfer before calling destructor");
  }
  // locally managed non-Qt objects
  delete _event_listeners;
  _event_listeners = 0;
  delete _status_listeners;
  _status_listeners = 0;
  delete[] _buffer;
  _buffer = 0;
  _name.clear();
  _group_name.clear();

  // elsewhere managed objects
  _filestream = 0;

  _id = 0;
  _pause_requested = false;
  _resume_requested = false;
  _quit_requested = false;
  _is_running = false;
  _buffer_size = 0;
}

void
Line::quit()
{
  if (!_transfer_thread) {
    Log::fatal("Line::quit(): already called");
  }
  _quit_requested = true;
  {
    std::stringstream msg;
    msg << "[D2a] " << to_string()
        << ", _resume_requested=" << _resume_requested
        << ", _quit_requested=" << _quit_requested;
    Log::trace(msg.str());
  }
  //const std::lock_guard<std::mutex> lock(_atomic_handle_interrupt);
  {
    std::stringstream msg;
    msg << "[D2b] " << to_string()
        << ", _resume_requested=" << _resume_requested
        << ", _quit_requested=" << _quit_requested;
    Log::trace(msg.str());
  }
  _interrupt_condition.notify_all();
  {
    std::stringstream msg;
    msg << "[D3] " << to_string();
    Log::trace(msg.str());
  }
  _transfer_thread->join();
  {
    std::stringstream msg;
    msg << "[D4] " << to_string();
    Log::trace(msg.str());
  }
  delete _transfer_thread;
  _transfer_thread = 0;
}

const uint32_t
Line::get_id() const
{
  return _id;
}

const Line::line_type_t
Line::get_line_type() const
{
  return _line_type;
}

const std::string
Line::get_name() const
{
  return _name;
}

const std::string
Line::get_full_name() const
{
  std::stringstream str;
  str
    << _group_name
    << " "
    << line_type_as_string();
  return str.str();
}

void
Line::add_status_listener(ILine_status_listener *listener)
{
  if (!listener) {
    Log::fatal("Line::add_status_listener(): "
               "listener is NULL");
  }
  if (!_status_listeners) {
    Log::fatal("Line::add_status_listener(): "
               "_status_listeners is NULL");
  }
  _status_listeners->push_back(listener);
}

void
Line::remove_status_listener(ILine_status_listener *listener)
{
  if (!listener) {
    Log::fatal("Line::remove_status_listener(): "
               "listener is NULL");
  }
  if (!_status_listeners) {
    Log::fatal("Line::remove_status_listener(): "
               "_status_listeners is NULL");
  }
  auto tail_start =
    std::remove(_status_listeners->begin(),
                _status_listeners->end(),
                listener);
  _status_listeners->erase(tail_start, _status_listeners->end());
}

void
Line::add_event_listener(ISerial_event_listener *listener)
{
  if (!listener) {
    Log::fatal("Line::add_event_listener(): "
               "listener is NULL");
  }
  if (!_event_listeners) {
    Log::fatal("Line::add_event_listener(): "
               "_event_listeners is NULL");
  }
  _event_listeners->push_back(listener);
}

void
Line::remove_event_listener(ISerial_event_listener *listener)
{
  if (!listener) {
    Log::fatal("Line::remove_event_listener(): "
               "listener is NULL");
  }
  if (!_event_listeners) {
    Log::fatal("Line::remove_event_listener(): "
               "_event_listeners is NULL");
  }
  auto tail_start =
    std::remove(_event_listeners->begin(),
                _event_listeners->end(),
                listener);
  _event_listeners->erase(tail_start, _event_listeners->end());
}

void
Line::notify_event_listeners(const Serial_event *event)
{
  const int size = _event_listeners->size();
  for (int index = 0; index < size; index++) {
    ISerial_event_listener *listener = (*_event_listeners)[index];
    listener->notify_event(event);
    {
      std::stringstream msg;
      msg << "QQQQQQQ Line::notify_event_listeners(): notify "
          << typeid(*listener).name();
      Log::trace(msg.str());
    }
  }
}

inline void
Line::started() {
  const int size = _status_listeners->size();
  for (int index = 0; index < size; index++) {
    ILine_status_listener *listener = (*_status_listeners)[index];
    listener->line_started(this);
  }
  const Serial_event event = Serial_event::create_stream_started(this);
  notify_event_listeners(&event);
}

void
Line::start(const bool ignore_status)
{
  const std::lock_guard<std::mutex> lock(_serialize_start_stop);
  std::stringstream msg;
  msg << "Line::start(): starting " << to_string();
  Log::debug(msg.str());
  if (!_is_running) {
    _resume_requested = true;
    _interrupt_condition.notify_all();
    std::stringstream msg;
    msg << "Line::start(): notified " << to_string();
    Log::debug(msg.str());
  } else if (!ignore_status) {
    std::stringstream msg;
    msg << "Line::start(): " << to_string() << " already started";
    Log::warn(msg.str());
  }

}

inline void
Line::stopped() {
  const Serial_event event = Serial_event::create_stream_stopped(this);
  notify_event_listeners(&event);
  const int size = _status_listeners->size();
  for (int index = 0; index < size; index++) {
    ILine_status_listener *listener = (*_status_listeners)[index];
    listener->line_stopped(this);
  }
}

void
Line::stop(const bool ignore_status)
{
  {
    std::stringstream msg;
    msg << "[LINE0] stop "
        << _id;
    Log::trace(msg.str());
  }
  const std::lock_guard<std::mutex> lock(_serialize_start_stop);
  {
    std::stringstream msg;
    msg << "[LINE1] stop "
        << _id;
    Log::trace(msg.str());
  }
  if (_is_running) {
    _pause_requested = true;
    {
      std::stringstream msg;
      msg << "[N1] Line::stop(): stopping " << to_string();
      Log::trace(msg.str());
    }
    _interrupt_condition.notify_all();
    {
      std::stringstream msg;
      msg << "[N2] Line::stop(): stopping " << to_string();
      Log::trace(msg.str());
    }
    // TODO:
    //sigaction(SIGINT, NULL, &_old_transfer_interrupt);
    //if (_old_transfer_interrupt.sa_handler != SIG_IGN)
    //  sigaction(SIGINT, &_transfer_interrupt, NULL);
    //
    // ALTERNATIVELY:
    //sigqueue(_transfer_thread->get_id(), SIGUSR1, (void *)this);
  } else if (!ignore_status) {
    std::stringstream msg;
    msg << "Line::stop(): " << to_string() << " already stopped";
    Log::warn(msg.str());
  }
  {
    std::stringstream msg;
    msg << "[LINE2] stop "
        << _id;
    Log::trace(msg.str());
  }
}

const bool
Line::is_running() const
{
  return _is_running;
}

std::unique_lock<std::mutex>
Line::acquire_interrupt_lock()
{
  std::unique_lock<std::mutex> lock(_atomic_handle_interrupt);
  return lock;
}

std::condition_variable *
Line::get_interrupt_condition()
{
  return &_interrupt_condition;
}

void
Line::serialize_with_start_stop(const std::function<void ()> critical_section)
{
  const std::lock_guard<std::mutex> lock(_serialize_start_stop);
  critical_section();
}

void
Line::atomic_access_buffer(const std::function<void ()> critical_section)
{
  const std::lock_guard<std::mutex> lock(_atomic_access_buffer);
  critical_section();
}

void
Line::transfer_loop_static(Line *line)
{
  line->transfer_loop();
}

void
Line::transfer_loop_phase_run()
{
  started();
  while (!_pause_requested && !_quit_requested) {
    transfer();
    {
      std::stringstream msg;
      msg << "[P1] " << to_string()
          << ", _pause_requested=" << _pause_requested
          << ", _resume_requested=" << _resume_requested
          << ", _quit_requested=" << _quit_requested;
      Log::trace(msg.str());
    }
  }
  _pause_requested = false;
}

void
Line::transfer_loop_phase_sleep()
{
  stopped();
  {
    std::stringstream msg;
    msg << "[L1] " << to_string();
    Log::trace(msg.str());
  }
  std::unique_lock<std::mutex> lock(_atomic_handle_interrupt);
  {
    std::stringstream msg;
    msg << "[L2] " << to_string();
    Log::trace(msg.str());
  }
  while (!_resume_requested && !_quit_requested) {
    {
      std::stringstream msg;
      msg << "[L2b] " << to_string();
      Log::trace(msg.str());
    }
    _interrupt_condition.wait_for(lock, std::chrono::milliseconds(1010));
    {
      std::stringstream msg;
      msg << "[L2c] " << to_string()
          << ", _resume_requested=" << _resume_requested
          << ", _quit_requested=" << _quit_requested;
      Log::trace(msg.str());
    }
  }
  {
    std::stringstream msg;
    msg << "[L5] " << to_string();
    Log::trace(msg.str());
  }
  _resume_requested = false;
}

void
Line::transfer_loop()
{
  {
    std::stringstream msg;
    msg << "enter line transfer loop for line " << _id;
    Log::debug(msg.str());
  }
  while (true) {
    _is_running = false;
    transfer_loop_phase_sleep();
    if (_quit_requested) break;
    _is_running = true;
    transfer_loop_phase_run();
    if (_quit_requested) break;
  }
  /*
  if (_is_running) {
    stopped();
  }
  */
  {
    std::stringstream msg;
    msg << "leave line transfer loop for line " << _id;
    Log::debug(msg.str());
  }
  _quit_requested = false;
}

void
Line::handle_transfer_interrupt(const int signum)
{
  // TODO: This is a static method. How to get pointer to line instance?
  //
  // Answer: We create the transfer thread as follows:
  //     _transfer_thread = new std::thread(...);
  // After that, _transfer_thread will contain the thread id.
  // Put (_transfer_thread->get_id(), this) into a static member map that
  // maps std::thread::id to Line.
  // In this static method, get the thread id via std::this_thread::get_id().
  // Given this id, lookup the "this" pointer in the
  // statically accessible map.  Call whatever member method
  // on the "this" object.

  std::stringstream msg;
  msg << " transfer: caught signal" << signum;
  Log::debug(msg.str());
  // TODO: Perform any resume actions?
}

const std::string
Line::line_type_as_string() const
{
  const line_type_t line_type = get_line_type();
  switch (line_type) {
  case rx:
    return STR_RX;
  case tx:
    return STR_TX;
  default:
    Log::fatal("unexpected case fall-through");
    return {};
  }
}

const std::string
Line::to_string() const
{
  return get_full_name();
}
