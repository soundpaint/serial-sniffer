/*
 * serial-sniffer -- a serial port sniffer and logger
 *
 * Copyright (C) 2021 JÃ¼rgen Reuter
 *
 * This file is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published
 * by the Free Software Foundation; either version 2 of the License,
 * or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 *
 * As a special exception to the GNU General Public License, if you
 * distribute this file as part of a program that contains a
 * configuration script generated by Autoconf, you may include it
 * under the same distribution terms that you use for the rest of that
 * program.
 *
 * For updates and more info or contacting the author, visit:
 * <https://github.com/soundpaint/serial-sniffer>
 *
 * Author's web site: www.juergen-reuter.de
 */

#include <line-out.hh>
#include <sstream>
#include <unistd.h>
#include <log.hh>

Line_out::Line_out(const std::string group_name,
                   const int filestream,
                   const uint32_t buffer_size)
  : Line(tx, std::string("TX"), group_name, filestream, buffer_size)
{
  _event_filter =
    new Serial_event_default_filter(NULL, Serial_event::rx_data_byte);
  _bytes_to_write = 0;
  _bytes_written = 0;
}

Line_out::~Line_out()
{
  // locally managed non-Qt objects
  delete _event_filter;
  _event_filter = 0;

  _bytes_to_write = 0;
  _bytes_written = 0;
}

void
Line_out::filter_for_line(const ILine_info *line_info)
{
  _event_filter->set_line_info(line_info);
}

#define SIMULATE

void
Line_out::transfer_prework()
{
#ifdef SIMULATE
  /*
  usleep(2000000);
  const Serial_event event = Serial_event::create_receive_data(this, 0);
  _buffer[0] = event.get_data_byte();
  _bytes_to_write = sizeof(_buffer[0]);
  */
#else
  // TODO: Pull model: The transmitter must provide a method that
  // gets called for the next data to be transmitted rather than the
  // transmitter calling a transmit() method).  Hence, call
  // transmission data producer, e.g. like:
  //
  //   _bytes_to_write = _event_producer(&_buffer, _buffer_size);
  //   transmit_event(&event);
  //
  // The producer should put into the buffer as many data bytes as it
  // has, but at most _buffer_size bytes, and return the number of
  // bytes that it has put into the buffer.
#endif
}

void
Line_out::transfer()
{
#ifdef SIMULATE
  _bytes_written = _bytes_to_write;
  usleep(2990000);
#else
  _bytes_written = 0;
  while (_bytes_written < _bytes_to_write) {
    if (_filestream != -1) {
      const int write_result =
        write(_filestream, &_buffer[_bytes_written],
              _bytes_to_write - _bytes_written);
      if (write_result < 0) {
        switch (errno) {
        case EINTR:
          // TODO: Check if line was requested to stop.
          {
            std::stringstream msg;
            msg << "Line_out::transfer_postwork(): errno=" << errno << "(EINTR)";
            Log::warn(msg.str());
          }
          break;
        default:
          {
            std::stringstream msg;
            msg << "Line_out::transfer_postwork(): errno=" << errno;
            Log::warn(msg.str());
          }
          break;
        }
        // limit bandwidth of retrials just in case of a permanent error
        usleep(4000000);
        break; // abort write
      } else if (write_result == 0) {
        // limit bandwidth of retrials just in case of a permanent error
        usleep(4000000);
        // retry write
      } else {
        _bytes_written += write_result;
      }
    } else {
      // line stopped while in write() => drop data
      _bytes_written = -1;
      errno = EINTR;
      break;
    }
  }
#endif
  if (_bytes_written < _bytes_to_write) {
    std::stringstream msg;
    msg << "Line_out::transmit_postwork(): errno=" << errno;
    Log::warn(msg.str());
  } else {
    Log::trace("AAAAAAAAA");
    {
      std::stringstream msg;
      msg << "_bytes_to_write=" << _bytes_to_write
          << ", _bytes_written=" << _bytes_written;
      Log::trace(msg.str());
    }
    for (uint32_t i = 0; i < _bytes_written; i++) {
      const Serial_event event =
        Serial_event::create_transmit_data(this, _buffer[i]);
      //Log::trace(event.to_string());
      notify_event_listeners(&event);
    }
    Log::trace("BBBBBBBBB");
  }
  if (!_bytes_to_write) {
    // reduce costs of spinning when idle
    std::this_thread::yield();
  }
  _bytes_to_write = 0;
}

void
Line_out::transfer_postwork()
{
}

void
Line_out::notify_event(const Serial_event *event)
{
  {
    std::stringstream msg;
    msg << "ZZZZZZZZZZ Line_out::notify_event(): "
        << "got event " << event->to_string()
        << " on line " << to_string();
    Log::trace(msg.str());
  }
  if (_event_filter && !_event_filter->accept(event)) {
    return;
  }
  {
    std::stringstream msg;
    msg << "ZZZZZZZZZ2 Line_out::notify_event(): "
        << "got event " << event->to_string()
        << " on line " << to_string();
    Log::trace(msg.str());
  }
  // serialize with start / stop to ensure that this line is not being
  // started or stopped while we are in the process of deciding
  // whether to propagate events.
  serialize_with_start_stop([&] () {
      {
        std::stringstream msg;
        msg << "ZZZZ0 is_running=" << is_running()
            << ", line=" << to_string();
        Log::trace(msg.str());
      }
      if (is_running()) {
        atomic_access_buffer([&] () {
            {
              std::stringstream msg;
              msg << "ZZZZA _bytes_to_write=" << _bytes_to_write
                  << ", line=" << to_string();
              Log::trace(msg.str());
            }
            if (_bytes_to_write < _buffer_size) {
              _buffer[_bytes_to_write] = event->get_data_byte();
              _bytes_to_write += sizeof(_buffer[0]);
            } else {
              std::stringstream msg;
              msg << "ZZZZB Line_out::notify_event(): buffer overflow"
                  << ", line=" << to_string();
              Log::warn(msg.str());
            }
            {
              std::stringstream msg;
              msg << "ZZZZB _bytes_to_write=" << _bytes_to_write
                  << ", line=" << to_string();
              Log::trace(msg.str());
            }
          });
      } else {
        std::stringstream msg;
        msg << "ZZZZC _bytes_to_write=" << _bytes_to_write
            << ", line=" + to_string();
        Log::trace(msg.str());
      }
    });
  {
    std::stringstream msg;
    msg << "ZZZZD _bytes_to_write=" << _bytes_to_write
        << ", line=" + to_string();
    Log::trace(msg.str());
  }
}

std::ostream &operator <<(std::ostream &os, const Line_out &line_out)
{
  os << "Line_out(name=" << line_out.get_name()
     << ", id=" << line_out.get_id() << ")";
  return os;
}

/*
 * Local variables:
 *   mode: c++
 *   coding: utf-8
 * End:
 */
