/*
 * serial-sniffer -- a serial port sniffer and logger
 *
 * Copyright (C) 2021 JÃ¼rgen Reuter
 *
 * This file is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published
 * by the Free Software Foundation; either version 2 of the License,
 * or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 *
 * As a special exception to the GNU General Public License, if you
 * distribute this file as part of a program that contains a
 * configuration script generated by Autoconf, you may include it
 * under the same distribution terms that you use for the rest of that
 * program.
 *
 * For updates and more info or contacting the author, visit:
 * <https://github.com/soundpaint/config-reader>
 *
 * Author's web site: www.juergen-reuter.de
 */

#include <string>
#include <fstream>
#include <regex>
#include <boost/format.hpp>
#include <xercesc/framework/LocalFileFormatTarget.hpp>
#include <config-writer.hh>
#include <log.hh>

#define NL "\n"

const std::string
Config_writer::STR_BOOL_FALSE = std::string("false");

const std::string
Config_writer::STR_BOOL_TRUE = std::string("true");

Config_writer::Config_writer(const Config *config)
{
  if (!config) {
    Log::fatal("Config_writer::Config_writer(): config is NULL");
  }
  _config = config;
  try {
    xercesc::XMLPlatformUtils::Initialize();
  } catch (xercesc::XMLException *exc) {
    char *message = xercesc::XMLString::transcode(exc->getMessage());
    std::stringstream full_msg;
    full_msg << "Config_writer::Config_writer(): "
      "failed initializing XML platform utils: " << message;
    xercesc::XMLString::release(&message);
    delete exc;
    Log::fatal(full_msg.str());
  }
}

Config_writer::~Config_writer()
{
  xercesc::XMLPlatformUtils::Terminate();
  _config = 0;
}

void
Config_writer::write_document(const std::string file_path)
{
  try {
    write_document_internal(file_path);
  } catch (xercesc::XMLException *exc) {
    char *message = xercesc::XMLString::transcode(exc->getMessage());
    Log::error(message);
    xercesc::XMLString::release(&message);
    delete exc;
    Log::fatal("failed writing XML document");
  }
}

void
Config_writer::write_document_internal(const std::string file_path)
{
  if (file_path.empty()) {
    Log::fatal("Config_writer::write_document(): file_path is empty");
  }
  xmlch_impl_id =
    xercesc::XMLString::transcode("Core");
  xmlch_entity_cfg_id =
    xercesc::XMLString::transcode("cfg");
  xmlch_entity_cfg_value =
    xercesc::XMLString::transcode("blob");
  xmlch_namespace_uri =
    xercesc::XMLString::transcode(CONFIG_NAMESPACE_URI);
  xmlch_dtd_id =
    xercesc::XMLString::transcode(CONFIG_DTD_ID);
  xmlch_public_id =
    xercesc::XMLString::transcode(CONFIG_PUBLIC_ID);
  xmlch_system_id =
    xercesc::XMLString::transcode(CONFIG_SYSTEM_ID);
  xmlch_root_elem_name =
    xercesc::XMLString::transcode("config");
  xmlch_xsi_ns_id =
    xercesc::XMLString::transcode("xmlns:xsi");
  xmlch_xsi_ns_value =
    xercesc::XMLString::transcode("http://www.w3.org/2001/XMLSchema-instance");
  xmlch_default_ns_id =
    xercesc::XMLString::transcode("xmlns");
  xmlch_default_ns_value =
    xercesc::XMLString::transcode("");
  xmlch_cfg_ns_id =
    xercesc::XMLString::transcode("xmlns:cfg");
  xmlch_cfg_ns_value =
    xercesc::XMLString::transcode("&cfg;");
  xmlch_schema_location_id =
    xercesc::XMLString::transcode("xsi:schemaLocation");
  xmlch_schema_location_value =
    xercesc::XMLString::transcode("&cfg; config.xsd");
  xercesc::DOMImplementation *impl =
    xercesc::DOMImplementationRegistry::getDOMImplementation(xmlch_impl_id);
  if (!impl) {
    Log::fatal("Config_writer::write_document(): "
               "no appropriate xerces DOM implementation found");
  }
  xercesc::DOMDocumentType *dtd =
    impl->createDocumentType(xmlch_dtd_id, xmlch_public_id, xmlch_system_id);
  xercesc::DOMDocument *document =
    impl->createDocument(0,                    // root element namespace URI
                         xmlch_root_elem_name, // root element name
                         dtd);                 // document type object (DTD)
  xercesc::DOMElement *elem_config = document->getDocumentElement();

  XMLCh *xmlch_nl = xercesc::XMLString::transcode(NL);
  xercesc::DOMText *nl = document->createTextNode(xmlch_nl);
  elem_config->appendChild(nl);
  xercesc::XMLString::release(&xmlch_nl);

  elem_config->setAttribute(xmlch_xsi_ns_id, xmlch_xsi_ns_value);
  elem_config->setAttribute(xmlch_default_ns_id, xmlch_default_ns_value);
  elem_config->setAttribute(xmlch_cfg_ns_id, xmlch_cfg_ns_value);
  elem_config->setAttribute(xmlch_schema_location_id,
                            xmlch_schema_location_value);

  build_document(document, elem_config);
  add_comment(document, document,
              "" NL
              "    Local Variables:" NL
              "      coding:utf-8" NL
              "      mode:xml" NL
              "    End:" NL,
              true, false);
  write_xml(document, file_path);
  if (document) {
    document->release();
    document = 0;
  }
  xercesc::XMLString::release((XMLCh **)&xmlch_impl_id);
  xercesc::XMLString::release((XMLCh **)&xmlch_namespace_uri);
  xercesc::XMLString::release((XMLCh **)&xmlch_dtd_id);
  xercesc::XMLString::release((XMLCh **)&xmlch_public_id);
  xercesc::XMLString::release((XMLCh **)&xmlch_system_id);
  xercesc::XMLString::release((XMLCh **)&xmlch_root_elem_name);
  xercesc::XMLString::release((XMLCh **)&xmlch_xsi_ns_id);
  xercesc::XMLString::release((XMLCh **)&xmlch_xsi_ns_value);
  xercesc::XMLString::release((XMLCh **)&xmlch_default_ns_id);
  xercesc::XMLString::release((XMLCh **)&xmlch_default_ns_value);
  xercesc::XMLString::release((XMLCh **)&xmlch_cfg_ns_id);
  xercesc::XMLString::release((XMLCh **)&xmlch_cfg_ns_value);
  xercesc::XMLString::release((XMLCh **)&xmlch_schema_location_id);
  xercesc::XMLString::release((XMLCh **)&xmlch_schema_location_value);
}

void
Config_writer::build_document(xercesc::DOMDocument *document,
                              xercesc::DOMElement *elem_config)
{
  XMLCh *xmlch_devices = xercesc::XMLString::transcode("devices");
  xercesc::DOMElement *elem_devices =
    document->createElementNS(xmlch_default_ns_value, xmlch_devices);
  elem_config->appendChild(elem_devices);
  build_devices(document, elem_devices);
  xercesc::XMLString::release(&xmlch_devices);
  add_line_break(document, elem_config);

  XMLCh *xmlch_logging = xercesc::XMLString::transcode("logging");
  xercesc::DOMElement *elem_logging =
    document->createElementNS(xmlch_default_ns_value, xmlch_logging);
  elem_config->appendChild(elem_logging);
  build_logging(document, elem_logging);
  xercesc::XMLString::release(&xmlch_logging);
  add_line_break(document, elem_config);

  XMLCh *xmlch_kiosk_mode = xercesc::XMLString::transcode("kiosk-mode");
  xercesc::DOMElement *elem_kiosk_mode =
    document->createElementNS(xmlch_default_ns_value, xmlch_kiosk_mode);
  elem_config->appendChild(elem_kiosk_mode);
  build_kiosk_mode(document, elem_kiosk_mode);
  xercesc::XMLString::release(&xmlch_kiosk_mode);
  add_line_break(document, elem_config);

  XMLCh *xmlch_key_bindings = xercesc::XMLString::transcode("key-bindings");
  xercesc::DOMElement *elem_key_bindings =
    document->createElementNS(xmlch_default_ns_value, xmlch_key_bindings);
  elem_config->appendChild(elem_key_bindings);
  build_key_bindings(document, elem_key_bindings);
  xercesc::XMLString::release(&xmlch_key_bindings);
  add_line_break(document, elem_config);

  XMLCh *xmlch_audio = xercesc::XMLString::transcode("audio");
  xercesc::DOMElement *elem_audio =
    document->createElementNS(xmlch_default_ns_value, xmlch_audio);
  elem_config->appendChild(elem_audio);
  build_audio(document, elem_audio);
  xercesc::XMLString::release(&xmlch_audio);
}

void
Config_writer::build_devices(xercesc::DOMDocument *document,
                             xercesc::DOMElement *elem_devices)
{
  // serial in path
  add_comment(document, elem_devices,
              " file path of serial input device ", false);
  xercesc::DOMElement *elem_serial_in =
    create_element(document, elem_devices, "serial-in");
  build_path(document, elem_serial_in, _config->get_serial_in_dev_path());

  // serial out path
  add_comment(document, elem_devices,
              " file path of serial output device ");
  xercesc::DOMElement *elem_serial_out =
    create_element(document, elem_devices, "serial-out");
  build_path(document, elem_serial_out, _config->get_serial_out_dev_path());

  // buffer size
  add_comment(document, elem_devices,
              " buffer size ");
  xercesc::DOMElement *elem_buffer_size =
    create_element(document, elem_devices, "buffer-size");
  add_text(document, elem_buffer_size,
           std::to_string(_config->get_serial_buffer_size()));

  // baud rate
  add_comment(document, elem_devices,
              " baud rate ");
  xercesc::DOMElement *elem_baud_rate =
    create_element(document, elem_devices, "baud-rate");
  add_text(document, elem_baud_rate,
           std::to_string(_config->get_serial_baud_rate()));

  // data bits
  add_comment(document, elem_devices,
              " number data bits, either 7 or 8 ");
  xercesc::DOMElement *elem_data_bits =
    create_element(document, elem_devices, "data-bits");
  add_text(document, elem_data_bits,
           Config::data_bits_to_string(_config->get_serial_data_bits()));

  // parity bit
  add_comment(document, elem_devices,
              " parity bit, one of \"none\", \"even\", \"odd\" ");
  xercesc::DOMElement *elem_parity_bit =
    create_element(document, elem_devices, "parity-bit");
  add_text(document, elem_parity_bit,
           Config::parity_bit_to_string(_config->get_serial_parity_bit()));

  // stop bits
  add_comment(document, elem_devices,
              " number stop bits, either 1 or 2 ");
  xercesc::DOMElement *elem_stop_bits =
    create_element(document, elem_devices, "stop-bits");
  add_text(document, elem_stop_bits,
           Config::stop_bits_to_string(_config->get_serial_stop_bits()));

  // auto start
  add_comment(document, elem_devices,
              " automatically start serial data streams on application start? ",
              false);
  xercesc::DOMElement *elem_auto_start =
    create_element(document, elem_devices, "auto-start");
  add_text(document, elem_auto_start,
           bool_as_text(_config->get_serial_auto_start()));
}

void
Config_writer::build_logging(xercesc::DOMDocument *document,
                             xercesc::DOMElement *elem_logging)
{
  // file logging
  add_comment(document, elem_logging,
              " enable / disable logging to file(s) on start ", false);
  xercesc::DOMElement *elem_enable_file_logging_on_start =
    create_element(document, elem_logging, "enable-file-logging-on-start");
  add_text(document, elem_enable_file_logging_on_start,
           bool_as_text(_config->get_log_enable_file_logging_on_start()));

  // dir path
  add_comment(document, elem_logging,
              " logging directory path ");
  xercesc::DOMElement *elem_dir_path =
    create_element(document, elem_logging, "dir-path");
  add_text(document, elem_dir_path, _config->get_log_dir_path());

  // filename pattern
  add_comment(document, elem_logging,
              " log filename pattern" NL
              NL
              "         supported pattern variables:" NL
              "         * $DATE: will be replaced with current date and time" NL
              NL
              "         * $UID: will be replace with ID that is unique among all log" NL
              "           files in the selected logging directory" NL
              NL
              "         Use \"$$\" as escape symbol for \"$\"." NL
              "    ");
  xercesc::DOMElement *elem_filename_pattern =
    create_element(document, elem_logging, "filename-pattern");
  add_text(document, elem_filename_pattern,
           _config->get_log_filename_pattern());

  // append on start
  add_comment(document, elem_logging,
              " enable / disable appending on start to existing log file ");
  xercesc::DOMElement *elem_append_on_start =
    create_element(document, elem_logging, "append-on-start");
  add_text(document, elem_append_on_start,
           bool_as_text(_config->get_log_append_on_start()));
}

void
Config_writer::build_kiosk_mode(xercesc::DOMDocument *document,
                                xercesc::DOMElement *elem_kiosk_mode)
{
  // full screen
  add_comment(document, elem_kiosk_mode,
              " start application in a window or full screen? ", false);
  xercesc::DOMElement *elem_full_screen =
    create_element(document, elem_kiosk_mode, "full-screen");
  add_text(document, elem_full_screen,
           bool_as_text(_config->get_full_screen()));

  // window width
  add_comment(document, elem_kiosk_mode,
              " if application is started in a window, use this window width" NL
              "         [px] ");
  xercesc::DOMElement *elem_window_width =
    create_element(document, elem_kiosk_mode, "window-width");
  add_text(document, elem_window_width,
           std::to_string(_config->get_window_width()));

  // window height
  add_comment(document, elem_kiosk_mode,
              " if application is started in a window, use this window height" NL
              "         [px] ");
  xercesc::DOMElement *elem_window_height =
    create_element(document, elem_kiosk_mode, "window-height");
  add_text(document, elem_window_height,
           std::to_string(_config->get_window_height()));

  // control show after pressing
  add_comment(document, elem_kiosk_mode,
              " show the control window after touching the screen the" NL
              "         specfied amount of seconds.  If set to 0, the control window" NL
              "         will never show this way ");
  xercesc::DOMElement *elem_control_show_after_pressing =
    create_element(document, elem_kiosk_mode, "control-show-after-pressing");
  add_text(document, elem_control_show_after_pressing,
           std::to_string(_config->get_control_show_after_pressing()));

  // control autohide after
  add_comment(document, elem_kiosk_mode,
              " hide the control window after the specfied amount of" NL
              "         seconds.  If set to 0, the control window will never hide ");
  xercesc::DOMElement *elem_control_autohide_after =
    create_element(document, elem_kiosk_mode, "control-autohide-after");
  add_text(document, elem_control_autohide_after,
           std::to_string(_config->get_control_autohide_after()));

  // enable cursor
  add_comment(document, elem_kiosk_mode,
              " enable / disable the X Window System or Wayland cursor ");
  xercesc::DOMElement *elem_enable_cursor =
    create_element(document, elem_kiosk_mode, "enable-cursor");
  add_text(document, elem_enable_cursor,
           bool_as_text(_config->get_enable_cursor()));

  // enable button quit
  add_comment(document, elem_kiosk_mode,
              " enable / disable display of \"quit\" button ");
  xercesc::DOMElement *elem_enable_button_quit =
    create_element(document, elem_kiosk_mode, "enable-button-quit");
  add_text(document, elem_enable_button_quit,
           bool_as_text(_config->get_enable_button_quit()));
}

void
Config_writer::build_key_bindings(xercesc::DOMDocument *document,
                                  xercesc::DOMElement *elem_key_bindings)
{
  add_comment(document, elem_key_bindings,
              "" NL
              "        NOTE: Some special keys like Qt::Space, Qt::Key_Left and" NL
              "        Qt::Key_Right may already be caught by the window manager for" NL
              "        window actions like browsing through the GUI.  If this is the" NL
              "        case, defining bindings for such keys in this section will" NL
              "        show no effect.  In doubt, for checking, replace it with a" NL
              "        regular key, like any of the 26 letter keys." NL
              "    ", false);

  // create action nodes
  int intAction = IKey_bindings::Menu;
  std::map<IKey_bindings::Action, xercesc::DOMElement *> action2elem_keys =
    std::map<IKey_bindings::Action, xercesc::DOMElement *>();
  do {
    const IKey_bindings::Action action =
      static_cast<IKey_bindings::Action>(intAction);
    xercesc::DOMElement *elem_keys =
      build_action(document, elem_key_bindings, action);
    std::map<IKey_bindings::Action, xercesc::DOMElement *>::iterator iter =
      action2elem_keys.find(action);
    if (iter != action2elem_keys.end()) {
      std::stringstream msg;
      msg << "Config_writer::build_key_bindings(): action " << action <<
        " already handled";
      Log::fatal(msg.str());
    }
    action2elem_keys[action] = elem_keys;
    intAction++;
  } while (intAction <= IKey_bindings::Audio_mute_unmute);

  // insert key nodes
  std::map<int, IKey_bindings::Action>::iterator iterator =
    _config->get_action_key_iterator_begin();
  for (; iterator != _config->get_action_key_iterator_end(); ++iterator) {
    const int key = iterator->first;
    const IKey_bindings::Action action = iterator->second;
    xercesc::DOMElement *elem_keys = action2elem_keys.find(action)->second;
    build_key(document, elem_keys, key);
  }
}

void
Config_writer::insert_key_node(xercesc::DOMDocument *document,
                               xercesc::DOMElement *elem_key_bindings,
                               const IKey_bindings::Action action,
                               const int key)
{
  const std::string str_action =
    std::string(IKey_bindings::action_to_string(action));
  const std::string str_expression =
    boost::str(boost::format(".//action/id[text()='%s']/../keys") % str_action);
  XMLCh *xmlch_expression =
    xercesc::XMLString::transcode(str_expression.c_str());
  xercesc::DOMElement *elem_config = document->getDocumentElement();
  if (!elem_config) {
    Log::fatal("missing document element");
  }
  xercesc::DOMXPathNSResolver *ns_resolver =
    document->createNSResolver(elem_config);
  XMLCh *xmlch_cfg_key =
    xercesc::XMLString::transcode("cfg");
  XMLCh *xmlch_cfg_value =
    xercesc::XMLString::transcode(CONFIG_NAMESPACE_URI);
  ns_resolver->addNamespaceBinding(xmlch_cfg_key, xmlch_cfg_value);
  xercesc::DOMXPathResult *xpath_result =
    document->evaluate(xmlch_expression,
                       elem_key_bindings,
                       ns_resolver,
                       xercesc::DOMXPathResult::FIRST_ORDERED_NODE_TYPE,
                       0);
  if (xpath_result) {
    if (xpath_result->isNode()) {
      xercesc::DOMNode *node_result = xpath_result->getNodeValue();
      xercesc::DOMElement *elem_keys =
        dynamic_cast<xercesc::DOMElement *>(node_result);
      if (!elem_keys) {
        Log::fatal("missing 'keys' XML element from XPath expression");
      }
      build_key(document, elem_keys, key);
    }
    xpath_result->release();
  }
  ns_resolver->release();
  xercesc::XMLString::release(&xmlch_expression);
  xercesc::XMLString::release(&xmlch_cfg_key);
  xercesc::XMLString::release(&xmlch_cfg_value);
}

xercesc::DOMElement *
Config_writer::build_action(xercesc::DOMDocument *document,
                            xercesc::DOMElement *elem_key_bindings,
                            const IKey_bindings::Action action)
{
  xercesc::DOMElement *elem_action =
    create_element(document, elem_key_bindings, "action");
  xercesc::DOMElement *elem_id =
    create_element(document, elem_action, "id");
  add_text(document, elem_id, IKey_bindings::action_to_string(action));
  return create_element(document, elem_action, "keys");
}

void
Config_writer::build_key(xercesc::DOMDocument *document,
                         xercesc::DOMElement *elem_keys,
                         const int key)
{
  xercesc::DOMElement *elem_key =
    create_element(document, elem_keys, "key");
  std::string hex_key = boost::str(boost::format("0x%08x") % key);
  add_text(document, elem_key, hex_key);
}

void
Config_writer::build_audio(xercesc::DOMDocument *document,
                           xercesc::DOMElement *elem_audio)
{
  std::stringstream formatter;
  formatter.imbue(Config::LOCALE_CONFIG_CPP);

  // enable audio
  add_comment(document, elem_audio,
              " enable / disable audio ", false);
  xercesc::DOMElement *elem_enable_audio =
    create_element(document, elem_audio, "enable-audio");
  add_text(document, elem_enable_audio,
           bool_as_text(_config->get_enable_audio()));

  // enable volume control
  add_comment(document, elem_audio,
              " enable / disable volume control ");
  xercesc::DOMElement *elem_enable_volume_control =
    create_element(document, elem_audio, "enable-volume-control");
  add_text(document, elem_enable_volume_control,
           bool_as_text(_config->get_enable_volume_control()));

  // sample scale
  add_comment(document, elem_audio,
              " global volume correction; should be usually 1.0 ");
  xercesc::DOMElement *elem_audio_sample_scale =
    create_element(document, elem_audio, "sample-scale");
  formatter.str("");
  formatter << _config->get_audio_sample_scale();
  add_text(document, elem_audio_sample_scale, formatter.str());

  // sample rate
  add_comment(document, elem_audio,
              " samples per second, usually 44100 ");
  xercesc::DOMElement *elem_audio_sample_rate =
    create_element(document, elem_audio, "sample-rate");
  add_text(document, elem_audio_sample_rate,
           std::to_string(_config->get_audio_sample_rate()));

  // channels
  add_comment(document, elem_audio,
              " for ordinary stereo, choose 2 channels ");
  xercesc::DOMElement *elem_audio_channels =
    create_element(document, elem_audio, "channels");
  add_text(document, elem_audio_channels,
           std::to_string(_config->get_audio_channels()));

  // alsa verbose
  add_comment(document, elem_audio,
              " if \"true\", be more verbose on ALSA specific operations ");
  xercesc::DOMElement *elem_alsa_verbose =
    create_element(document, elem_audio, "alsa-verbose");
  add_text(document, elem_alsa_verbose,
           bool_as_text(_config->get_alsa_verbose()));

  // alsa playback device
  add_comment(document, elem_audio,
              " if \"default\" does not work, try \"plughw:0,0\" instead ");
  xercesc::DOMElement *elem_alsa_playback_device =
    create_element(document, elem_audio, "alsa-playback-device");
  add_text(document, elem_alsa_playback_device,
           _config->get_alsa_playback_device());

  // alsa buffer time
  add_comment(document, elem_audio,
              " size of audio buffer in [Âµs] ");
  xercesc::DOMElement *elem_alsa_buffer_time =
    create_element(document, elem_audio, "alsa-buffer-time");
  add_text(document, elem_alsa_buffer_time,
           std::to_string(_config->get_alsa_buffer_time()));

  // alsa period time
  add_comment(document, elem_audio,
              " period time in [Âµs] ");
  xercesc::DOMElement *elem_alsa_period_time =
    create_element(document, elem_audio, "alsa-period-time");
  add_text(document, elem_alsa_period_time,
           std::to_string(_config->get_alsa_period_time()));

  // initial volume
  add_comment(document, elem_audio,
              " minimum volume is 0.0, maximum volume is 1.0 ");
  xercesc::DOMElement *elem_audio_initial_volume =
    create_element(document, elem_audio, "initial-volume");
  formatter.str("");
  formatter << _config->get_audio_initial_volume();
  add_text(document, elem_audio_initial_volume, formatter.str());
}

void
Config_writer::build_path(xercesc::DOMDocument *document,
                          xercesc::DOMElement *elem_parent,
                          const std::string text)
{
  XMLCh *xmlch_path = xercesc::XMLString::transcode("path");
  xercesc::DOMElement *elem_path =
    document->createElementNS(xmlch_default_ns_value, xmlch_path);
  elem_parent->appendChild(elem_path);
  XMLCh *xmlch_text = xercesc::XMLString::transcode(text.c_str());
  xercesc::DOMText *node_text = document->createTextNode(xmlch_text);
  elem_path->appendChild(node_text);
  xercesc::XMLString::release(&xmlch_text);
  xercesc::XMLString::release(&xmlch_path);
}

xercesc::DOMElement *
Config_writer::create_element(xercesc::DOMDocument *document,
                              xercesc::DOMElement *elem_parent,
                              const char *str_q_name)
{
  XMLCh *xmlch_q_name = xercesc::XMLString::transcode(str_q_name);
  xercesc::DOMElement *element =
    document->createElementNS(xmlch_default_ns_value, xmlch_q_name);
  elem_parent->appendChild(element);
  xercesc::XMLString::release(&xmlch_q_name);
  return element;
}

void
Config_writer::add_text(xercesc::DOMDocument *document,
                        xercesc::DOMNode *node_parent,
                        const std::string str_text)
{
  XMLCh *xmlch_text = xercesc::XMLString::transcode(str_text.c_str());
  xercesc::DOMText *text = document->createTextNode(xmlch_text);
  node_parent->appendChild(text);
  xercesc::XMLString::release(&xmlch_text);
}

void
Config_writer::add_comment(xercesc::DOMDocument *document,
                           xercesc::DOMNode *node_parent,
                           const std::string str_comment,
                           const bool prepend_empty_line,
                           const bool append_empty_line)
{
  if (prepend_empty_line) add_line_break(document, node_parent);
  XMLCh *xmlch_comment = xercesc::XMLString::transcode(str_comment.c_str());
  xercesc::DOMComment *comment = document->createComment(xmlch_comment);
  node_parent->appendChild(comment);
  xercesc::XMLString::release(&xmlch_comment);
  if (append_empty_line) add_line_break(document, node_parent);
}

void
Config_writer::add_line_break(xercesc::DOMDocument *document,
                              xercesc::DOMNode *node_parent)
{
  add_text(document, node_parent, std::string(NL));
}

const std::string
Config_writer::bool_as_text(const bool value)
{
  return value ? STR_BOOL_TRUE : STR_BOOL_FALSE;
}

void
Config_writer::add_missing_entity_declaration(std::string *str_document) const
{
  std::regex pattern("(<!DOCTYPE config)(>)");
  std::string result =
    std::regex_replace(*str_document, pattern,
                       "$1[" NL
                       "  <!ENTITY cfg \"http://www.soundpaint.org/2019/serial-sniffer/config\">" NL
                       "]$2" NL);
  str_document->clear();
  str_document->append(result);
}

void
Config_writer::prepend_xml_declaration(std::string *str_document) const
{
  std::string decl =
    std::string("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
  str_document->insert(0, decl);
}

void
Config_writer::fix_attributes_indentation(std::string *str_document) const
{
  std::string result = std::string(*str_document);
  std::regex pattern;

  pattern = std::regex("( )(xmlns=)");
  result = std::regex_replace(result, pattern, NL "    $2");
  pattern = std::regex("( )(xmlns:cfg=)");
  result = std::regex_replace(result, pattern, NL "    $2");
  pattern = std::regex("( )(xmlns:xsi=)");
  result = std::regex_replace(result, pattern, NL "    $2");
  pattern = std::regex("( )(xsi:schemaLocation=)");
  result = std::regex_replace(result, pattern, NL "    $2");

  str_document->clear();
  str_document->append(result);
}

void
Config_writer::fix_entity_references(std::string *str_document) const
{
  std::regex pattern("&amp;cfg;");
  std::string result = std::regex_replace(*str_document, pattern, "&cfg;");
  str_document->clear();
  str_document->append(result);
}

void
Config_writer::fix_default_namespace(std::string *str_document) const
{
  std::regex pattern("(xmlns=\")(\")");
  std::string result = std::regex_replace(*str_document, pattern, "$1&cfg;$2");
  str_document->clear();
  str_document->append(result);
}

void
Config_writer::fix_xml(std::string *str_document) const
{
  add_missing_entity_declaration(str_document);
  prepend_xml_declaration(str_document);
  fix_attributes_indentation(str_document);
  fix_entity_references(str_document);
  fix_default_namespace(str_document);
}

void
Config_writer::write_to_file(const std::string *content,
                             const std::string file_path) const
{
  std::ofstream out(file_path);
  out << *content;
  out.close();
}

void
Config_writer::write_xml(const xercesc::DOMNode *node,
                         const std::string file_path) const
{
  // get implementation wth load / save feature
  XMLCh *xmlch_ls = xercesc::XMLString::transcode("LS");
  xercesc::DOMImplementation *implementation =
    xercesc::DOMImplementationRegistry::getDOMImplementation(xmlch_ls);
  xercesc::DOMLSSerializer *serializer =
    ((xercesc::DOMImplementationLS*)implementation)->createLSSerializer();

  // make the output more human readable by inserting line feeds
  xercesc::DOMConfiguration *configuration = serializer->getDomConfig();
  if (configuration->
      canSetParameter(xercesc::XMLUni::fgDOMXMLDeclaration, false)) {
    configuration->
      setParameter(xercesc::XMLUni::fgDOMXMLDeclaration, false);
  }
  if (configuration->
      canSetParameter(xercesc::XMLUni::fgDOMWRTFormatPrettyPrint, true)) {
    configuration->
      setParameter(xercesc::XMLUni::fgDOMWRTFormatPrettyPrint, true);
  }
  if (configuration->
      canSetParameter(xercesc::XMLUni::fgDOMWRTEntities, true)) {
    configuration->setParameter(xercesc::XMLUni::fgDOMWRTEntities, true);
  }

  serializer->setNewLine(xercesc::XMLString::transcode(NL));

  XMLCh *xmlch_document = serializer->writeToString(node);
  char *document_as_c_star = xercesc::XMLString::transcode(xmlch_document);
  std::string str_document = std::string(document_as_c_star);
  fix_xml(&str_document);
  write_to_file(&str_document, file_path);
  xercesc::XMLString::release(&document_as_c_star);
  xercesc::XMLString::release(&xmlch_document);

  serializer->release();
}
