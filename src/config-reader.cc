/*
 * serial-sniffer -- a serial port sniffer and logger
 *
 * Copyright (C) 2021 JÃ¼rgen Reuter
 *
 * This file is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published
 * by the Free Software Foundation; either version 2 of the License,
 * or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 *
 * As a special exception to the GNU General Public License, if you
 * distribute this file as part of a program that contains a
 * configuration script generated by Autoconf, you may include it
 * under the same distribution terms that you use for the rest of that
 * program.
 *
 * For updates and more info or contacting the author, visit:
 * <https://github.com/soundpaint/config-reader>
 *
 * Author's web site: www.juergen-reuter.de
 */

#include <config-reader.hh>
#include <sstream>
#include <cerrno>
#include <unistd.h>
#include <log.hh>

Config_reader::Config_reader(Config *config)
  : Abstract_config_reader()
{
  if (!config) {
    Log::fatal("Config_reader::Config_reader(): config is NULL");
  }
  _config = config;
}

Config_reader::~Config_reader()
{
  // elsewhere managed objects
  _config = 0;
}

void
Config_reader::parse_document(const xercesc::DOMElement *elem_config)
{
  const XMLCh *node_name = elem_config->getLocalName();

  char *node_name_as_c_star = xercesc::XMLString::transcode(node_name);
  if (strcmp(node_name_as_c_star, "config")) {
    std::stringstream message;
    message << "Config_reader::parse_document(): "
      "unexpected document element: " << node_name_as_c_star;
    Log::fatal(message.str());
  }

  xercesc::XMLString::release(&node_name_as_c_star);
  node_name_as_c_star = 0;

  const xercesc::DOMElement *elem_devices =
    get_single_child_element(elem_config, "devices");
  if (elem_devices) {
    parse_devices(elem_devices);
  }

  const xercesc::DOMElement *elem_logging =
    get_single_child_element(elem_config, "logging");
  if (elem_logging) {
    parse_logging(elem_logging);
  }

  const xercesc::DOMElement *elem_kiosk_mode =
    get_single_child_element(elem_config, "kiosk-mode");
  if (elem_kiosk_mode) {
    parse_kiosk_mode(elem_kiosk_mode);
  }

  const xercesc::DOMElement *elem_key_bindings =
    get_single_child_element(elem_config, "key-bindings");
  if (elem_key_bindings) {
    parse_key_bindings(elem_key_bindings);
  }

  const xercesc::DOMElement *elem_audio =
    get_single_child_element(elem_config, "audio");
  if (elem_audio) {
    parse_audio(elem_audio);
  }
}

void
Config_reader::parse_devices(const xercesc::DOMElement *elem_devices)
{
  // serial-in
  const xercesc::DOMElement *elem_serial_in =
    get_single_child_element(elem_devices, "serial-in");
  if (elem_serial_in) {
    const XMLCh *path = parse_path(elem_serial_in);
    char *str_path = xercesc::XMLString::transcode(path);
    _config->set_serial_in_dev_path(str_path);
    xercesc::XMLString::release(&str_path);
    str_path = 0;
  }

  // serial-out
  const xercesc::DOMElement *elem_serial_out =
    get_single_child_element(elem_devices, "serial-out");
  if (elem_serial_out) {
    const XMLCh *path = parse_path(elem_serial_out);
    char *str_path = xercesc::XMLString::transcode(path);
    _config->set_serial_out_dev_path(str_path);
    xercesc::XMLString::release(&str_path);
    str_path = 0;
  }

  // buffer size
  const xercesc::DOMElement *elem_buffer_size =
    get_single_child_element(elem_devices, "buffer-size");
  if (elem_buffer_size) {
    const XMLCh *buffer_size =
      elem_buffer_size->getTextContent();
    const uint32_t buffer_size_value =
      parse_decimal_uint32(buffer_size);
    if (buffer_size_value < 0) {
      Log::fatal("Config_reader::parse_devices(): "
                 "buffer size value < 0");
    }
    _config->set_serial_buffer_size(buffer_size_value);
  }

  // baud rate
  const xercesc::DOMElement *elem_baud_rate =
    get_single_child_element(elem_devices, "baud-rate");
  if (elem_baud_rate) {
    const XMLCh *baud_rate =
      elem_baud_rate->getTextContent();
    const uint32_t baud_rate_value =
      parse_decimal_uint32(baud_rate);
    if (baud_rate_value < 0) {
      Log::fatal("Config_reader::parse_devices(): "
                 "baud rate value < 0");
    }
    _config->set_serial_baud_rate(baud_rate_value);
  }

  // data bits
  const xercesc::DOMElement *elem_data_bits =
    get_single_child_element(elem_devices, "data-bits");
  if (elem_data_bits) {
    const XMLCh *data_bits =
      elem_data_bits->getTextContent();
    const uint8_t data_bits_value =
      parse_decimal_uint8(data_bits);
    if (data_bits_value < 7) {
      Log::fatal("Config_reader::parse_devices(): "
                 "data bits value < 7");
    }
    if (data_bits_value > 8) {
      Log::fatal("Config_reader::parse_devices(): "
                 "data bits value > 8");
    }
    _config->set_serial_data_bits(data_bits_value == 7 ?
                                  IConfig::seven : IConfig::eight);
  }

  // parity bit
  const xercesc::DOMElement *elem_parity_bit =
    get_single_child_element(elem_devices, "parity-bit");
  if (elem_parity_bit) {
    parse_serial_parity_bit(elem_parity_bit);
  }

  // stop bits
  const xercesc::DOMElement *elem_stop_bits =
    get_single_child_element(elem_devices, "stop-bits");
  if (elem_stop_bits) {
    const XMLCh *stop_bits =
      elem_stop_bits->getTextContent();
    const uint8_t stop_bits_value =
      parse_decimal_uint8(stop_bits);
    if (stop_bits_value < 1) {
      Log::fatal("Config_reader::parse_devices(): "
                 "stop bits value < 1");
    }
    if (stop_bits_value > 2) {
      Log::fatal("Config_reader::parse_devices(): "
                 "stop bits value > 2");
    }
    _config->
      set_serial_stop_bits(stop_bits_value == 1 ? IConfig::one : IConfig::two);
  }

  // auto start
  const xercesc::DOMElement *elem_auto_start =
    get_single_child_element(elem_devices, "auto-start");
  if (elem_auto_start) {
    const XMLCh *auto_start =
      elem_auto_start->getTextContent();
    const bool auto_start_value = parse_bool(auto_start);
    _config->set_serial_auto_start(auto_start_value);
  }
}

void
Config_reader::parse_logging(const xercesc::DOMElement *elem_logging)
{
  // enable file logging on start
  const xercesc::DOMElement *elem_enable_file_logging_on_start =
    get_single_child_element(elem_logging, "enable-file-logging-on-start");
  if (elem_enable_file_logging_on_start) {
    const XMLCh *enable_file_logging_on_start =
      elem_enable_file_logging_on_start->getTextContent();
    const bool enable_file_logging_on_start_value =
      parse_bool(enable_file_logging_on_start);
    _config->
      set_log_enable_file_logging_on_start(enable_file_logging_on_start_value);
  }

  // log dir path
  const xercesc::DOMElement *elem_dir_path =
    get_single_child_element(elem_logging, "dir-path");
  if (elem_dir_path) {
    const XMLCh *dir_path = elem_dir_path->getTextContent();
    char *str_dir_path = xercesc::XMLString::transcode(dir_path);
    _config->set_log_dir_path(str_dir_path);
    xercesc::XMLString::release(&str_dir_path);
    str_dir_path = 0;
  }

  // log filename pattern
  const xercesc::DOMElement *elem_filename_pattern =
    get_single_child_element(elem_logging, "filename-pattern");
  if (elem_filename_pattern) {
    const XMLCh *filename_pattern = elem_filename_pattern->getTextContent();
    char *str_filename_pattern = xercesc::XMLString::transcode(filename_pattern);
    _config->set_log_filename_pattern(str_filename_pattern);
    xercesc::XMLString::release(&str_filename_pattern);
    str_filename_pattern = 0;
  }

  // append on start
  const xercesc::DOMElement *elem_append_on_start =
    get_single_child_element(elem_logging, "append-on-start");
  if (elem_append_on_start) {
    const XMLCh *append_on_start =
      elem_append_on_start->getTextContent();
    const bool append_on_start_value = parse_bool(append_on_start);
    _config->set_log_append_on_start(append_on_start_value);
  }
}

void
Config_reader::parse_serial_parity_bit(const xercesc::DOMElement *elem_parity_bit)
{
  const XMLCh *parity_bit = elem_parity_bit->getTextContent();
  char *token_as_c_star = xercesc::XMLString::transcode(parity_bit);
  IConfig::parity_bit_t parity_bit_value;
  if (xercesc::XMLString::equals(token_as_c_star, "none")) {
    parity_bit_value = IConfig::none;
  } else if (xercesc::XMLString::equals(token_as_c_star, "even")) {
    parity_bit_value = IConfig::even;
  } else if (xercesc::XMLString::equals(token_as_c_star, "odd")) {
    parity_bit_value = IConfig::odd;
  } else {
    std::stringstream full_msg;
    full_msg << "Config_reader::parse_parity_bit(): "
      "value is not a valid parity bit identifier: " << token_as_c_star;
    Log::fatal(full_msg.str());
  }
  xercesc::XMLString::release(&token_as_c_star);
  _config->set_serial_parity_bit(parity_bit_value);
}

void
Config_reader::parse_kiosk_mode(const xercesc::DOMElement *elem_kiosk_mode)
{
  // full screen
  const xercesc::DOMElement *elem_full_screen =
    get_single_child_element(elem_kiosk_mode, "full-screen");
  if (elem_full_screen) {
    const XMLCh *full_screen = elem_full_screen->getTextContent();
    const bool full_screen_value = parse_bool(full_screen);
    _config->set_full_screen(full_screen_value);
  }

  // window width
  const xercesc::DOMElement *elem_window_width =
    get_single_child_element(elem_kiosk_mode, "window-width");
  if (elem_window_width) {
    const XMLCh *window_width =
      elem_window_width->getTextContent();
    const uint16_t window_width_value =
      parse_decimal_uint16(window_width);
    if (window_width_value <= 0) {
      Log::fatal("Config_reader::parse_kiosk_mode(): "
                 "window_width <= 0");
    }
    _config->set_window_width(window_width_value);
  }

  // window height
  const xercesc::DOMElement *elem_window_height =
    get_single_child_element(elem_kiosk_mode, "window-height");
  if (elem_window_height) {
    const XMLCh *window_height =
      elem_window_height->getTextContent();
    const uint16_t window_height_value =
      parse_decimal_uint16(window_height);
    if (window_height_value <= 0) {
      Log::fatal("Config_reader::parse_kiosk_mode(): "
                 "window_height <= 0");
    }
    _config->set_window_height(window_height_value);
  }

  // control show after pressing
  const xercesc::DOMElement *elem_control_show_after_pressing =
    get_single_child_element(elem_kiosk_mode, "control-show-after-pressing");
  if (elem_control_show_after_pressing) {
    const XMLCh *control_show_after_pressing =
      elem_control_show_after_pressing->getTextContent();
    const uint16_t control_show_after_pressing_value =
      parse_decimal_uint16(control_show_after_pressing);
    if (control_show_after_pressing_value < 0) {
      Log::fatal("Config_reader::parse_kiosk_mode(): "
                 "control show after pressing < 0");
    }
    _config->set_control_show_after_pressing(control_show_after_pressing_value);
  }

  // control autohide after
  const xercesc::DOMElement *elem_control_autohide_after =
    get_single_child_element(elem_kiosk_mode, "control-autohide-after");
  if (elem_control_autohide_after) {
    const XMLCh *control_autohide_after =
      elem_control_autohide_after->getTextContent();
    const uint16_t control_autohide_after_value =
      parse_decimal_uint16(control_autohide_after);
    if (control_autohide_after_value < 0) {
      Log::fatal("Config_reader::parse_kiosk_mode(): "
                 "control autohide after < 0");
    }
    _config->set_control_autohide_after(control_autohide_after_value);
  }

  // enable cursor
  const xercesc::DOMElement *elem_enable_cursor =
    get_single_child_element(elem_kiosk_mode, "enable-cursor");
  if (elem_enable_cursor) {
    const XMLCh *enable_cursor = elem_enable_cursor->getTextContent();
    const bool enable_cursor_value = parse_bool(enable_cursor);
    _config->set_enable_cursor(enable_cursor_value);
  }

  // enable button quit
  const xercesc::DOMElement *elem_enable_button_quit =
    get_single_child_element(elem_kiosk_mode, "enable-button-quit");
  if (elem_enable_button_quit) {
    const XMLCh *enable_button_quit = elem_enable_button_quit->getTextContent();
    const bool enable_button_quit_value = parse_bool(enable_button_quit);
    _config->set_enable_button_quit(enable_button_quit_value);
  }
}

void
Config_reader::parse_key_bindings(const xercesc::DOMElement *elem_key_bindings)
{
  XMLCh *node_name_action = xercesc::XMLString::transcode("action");
  const xercesc::DOMNodeList *node_list =
    get_children_by_tag_name(elem_key_bindings, node_name_action);
  if (node_list) {
    const XMLSize_t length = node_list->getLength();
    for (uint32_t node_index = 0; node_index < length; node_index++) {
      const xercesc::DOMNode *node = node_list->item(node_index);
      const xercesc::DOMElement *action =
        dynamic_cast<const xercesc::DOMElement *>(node);
      if (!action) {
        Log::fatal("Config_reader::parse_key_bindings(): action is NULL");
      }
      parse_action(action);
    }
  } else {
    // no actions => nothing to parse
  }
  xercesc::XMLString::release(&node_name_action);
  delete node_list;
}

void
Config_reader::parse_action(const xercesc::DOMElement *elem_action)
{
  // id
  const xercesc::DOMElement *elem_id =
    get_single_child_element(elem_action, "id");
  if (!elem_id) {
    Log::fatal("Config_reader::parse_action(): id is NULL");
  }
  const XMLCh *id = elem_id->getTextContent();
  char *id_as_c_star = xercesc::XMLString::transcode(id);
  const IKey_bindings::Action action =
    IKey_bindings::action_from_string(id_as_c_star);
  if (action == IKey_bindings::None) {
    std::stringstream msg;
    msg << "Config_reader::parse_action(): unknown action id: " <<
      id_as_c_star;
    Log::fatal(msg.str());
  }
  xercesc::XMLString::release(&id_as_c_star);

  // keys
  const xercesc::DOMElement *elem_keys =
    get_single_child_element(elem_action, "keys");
  if (!elem_keys) {
    Log::fatal("Config_reader::parse_action(): keys is NULL");
  }
  parse_keys(elem_keys, action);

}

void
Config_reader::parse_keys(const xercesc::DOMElement *elem_keys,
                          const IKey_bindings::Action action)
{
  XMLCh *node_name_key = xercesc::XMLString::transcode("key");
  const xercesc::DOMNodeList *node_list =
    get_children_by_tag_name(elem_keys, node_name_key);
  if (node_list) {
    const XMLSize_t length = node_list->getLength();
    for (uint32_t node_index = 0; node_index < length; node_index++) {
      const xercesc::DOMNode *node = node_list->item(node_index);
      const xercesc::DOMElement *key =
        dynamic_cast<const xercesc::DOMElement *>(node);
      if (!key) {
        Log::fatal("Config_reader::parse_keys(): key is NULL");
      }
      parse_key(key, action);
    }
  } else {
    // no key => nothing to parse
  }
  xercesc::XMLString::release(&node_name_key);
  delete node_list;
}

void
Config_reader::parse_key(const xercesc::DOMElement *elem_key,
                         const IKey_bindings::Action action)
{
  const XMLCh *key = elem_key->getTextContent();
  const uint32_t key_code = parse_hex_or_dec_or_oct_int32(key);
  _config->bind_key_to_action(key_code, action);
}

void
Config_reader::parse_audio(const xercesc::DOMElement *elem_audio)
{
  // enable audio
  const xercesc::DOMElement *elem_enable_audio =
    get_single_child_element(elem_audio, "enable-audio");
  if (elem_enable_audio) {
    const XMLCh *enable_audio = elem_enable_audio->getTextContent();
    const bool enable_audio_value = parse_bool(enable_audio);
    _config->set_enable_audio(enable_audio_value);
  }

  // enable volume control
  const xercesc::DOMElement *elem_enable_volume_control =
    get_single_child_element(elem_audio, "enable-volume-control");
  if (elem_enable_volume_control) {
    const XMLCh *enable_volume_control =
      elem_enable_volume_control->getTextContent();
    const bool enable_volume_control_value = parse_bool(enable_volume_control);
    _config->set_enable_volume_control(enable_volume_control_value);
  }

  // audio sample scale
  const xercesc::DOMElement *elem_sample_scale =
    get_single_child_element(elem_audio, "sample-scale");
  if (elem_sample_scale) {
    const XMLCh *sample_scale = elem_sample_scale->getTextContent();
    const double sample_scale_value = parse_double(sample_scale);
    _config->set_audio_sample_scale(sample_scale_value);
  }

  // audio sample rate
  const xercesc::DOMElement *elem_audio_sample_rate =
    get_single_child_element(elem_audio, "audio-sample-rate");
  if (elem_audio_sample_rate) {
    const XMLCh *audio_sample_rate = elem_audio_sample_rate->getTextContent();
    const uint32_t audio_sample_rate_value =
      parse_decimal_uint32(audio_sample_rate);
    if (audio_sample_rate_value < 0) {
      Log::fatal("Config_reader::parse_audio(): "
                 "audio sample rate value < 0");
    }
    _config->set_audio_sample_rate(audio_sample_rate_value);
  }

  // audio channels
  const xercesc::DOMElement *elem_audio_channels =
    get_single_child_element(elem_audio, "audio-channels");
  if (elem_audio_channels) {
    const XMLCh *audio_channels = elem_audio_channels->getTextContent();
    const uint32_t audio_channels_value =
      parse_decimal_uint32(audio_channels);
    if (audio_channels_value < 0) {
      Log::fatal("Config_reader::parse_audio(): "
                 "audio channels value < 0");
    }
    _config->set_audio_channels(audio_channels_value);
  }

  // alsa verbose
  const xercesc::DOMElement *elem_alsa_verbose =
    get_single_child_element(elem_audio, "alsa-verbose");
  if (elem_alsa_verbose) {
    const XMLCh *alsa_verbose = elem_alsa_verbose->getTextContent();
    const bool alsa_verbose_value = parse_bool(alsa_verbose);
    _config->set_alsa_verbose(alsa_verbose_value);
  }

  // alsa playback device
  const xercesc::DOMElement *elem_alsa_playback_device =
    get_single_child_element(elem_audio, "alsa-playback-device");
  if (elem_alsa_playback_device) {
    const XMLCh *alsa_playback_device =
      elem_alsa_playback_device->getTextContent();
    char *alsa_playback_device_value =
      xercesc::XMLString::transcode(alsa_playback_device);

    _config->set_alsa_playback_device(alsa_playback_device_value);
    xercesc::XMLString::release(&alsa_playback_device_value);
    alsa_playback_device_value = 0;
  }

  // alsa buffer time
  const xercesc::DOMElement *elem_alsa_buffer_time =
    get_single_child_element(elem_audio, "alsa-buffer-time");
  if (elem_alsa_buffer_time) {
    const XMLCh *alsa_buffer_time = elem_alsa_buffer_time->getTextContent();
    const uint32_t alsa_buffer_time_value =
      parse_decimal_uint32(alsa_buffer_time);
    if (alsa_buffer_time_value < 0) {
      Log::fatal("Config_reader::parse_audio(): "
                 "alsa buffer time value < 0");
    }
    _config->set_alsa_buffer_time(alsa_buffer_time_value);
  }

  // alsa period time
  const xercesc::DOMElement *elem_alsa_period_time =
    get_single_child_element(elem_audio, "alsa-period-time");
  if (elem_alsa_period_time) {
    const XMLCh *alsa_period_time = elem_alsa_period_time->getTextContent();
    const uint32_t alsa_period_time_value =
      parse_decimal_uint32(alsa_period_time);
    if (alsa_period_time_value < 0) {
      Log::fatal("Config_reader::parse_audio(): "
                 "alsa period time value < 0");
    }
    _config->set_alsa_period_time(alsa_period_time_value);
  }

  // initial volume
  const xercesc::DOMElement *elem_initial_volume =
    get_single_child_element(elem_audio, "initial-volume");
  if (elem_initial_volume) {
    const XMLCh *initial_volume = elem_initial_volume->getTextContent();
    const double initial_volume_value = parse_double(initial_volume);
    if (initial_volume_value < 0.0) {
      Log::fatal("Config_reader::parse_audio(): initial volume < 0.0");
    }
    if (initial_volume_value > 1.0) {
      Log::fatal("Config_reader::parse_audio(): initial volume > 1.0");
    }
    _config->set_audio_initial_volume(initial_volume_value);
  }
}

const XMLCh *
Config_reader::parse_path(const xercesc::DOMElement *elem_parent)
{
  const xercesc::DOMElement *elem_path =
    get_single_child_element(elem_parent, "path");
  if (!elem_path) {
    Log::fatal("Config_reader::parse_path(): "
               "missing path element");
  }
#if 1
  const XMLCh *node_value_path = elem_path->getTextContent();
#else
  const xercesc::DOMNode *child_node = elem_path->getFirstChild();
  const xercesc::DOMText *text_node =
    dynamic_cast<const xercesc::DOMText *>(child_node);
  if (!child_node) {
    Log::fatal("Config_reader::parse_path(): "
               "failed retrieving text node");
  }
  const XMLCh *node_value_path = text_node->getWholeText();
#endif
  return node_value_path;
}

void
Config_reader::print_config() const
{
  std::stringstream msg;
  msg << std::endl;
  msg << "######## CONFIG BEGIN ########" << std::endl;
  _config->to_string(&msg);
  msg << "######### CONFIG END ###########" << std::endl;
  Log::info(msg.str());
}

/*
 * Local variables:
 *   mode: c++
 *   coding: utf-8
 * End:
 */
